\documentclass{article}
\usepackage{ltxtable}

\frenchspacing

\title{\Huge Mutalyzer 2.0}
\author{Jeroen F.J. Laros, Martijn Vermaat, Gerben R. Stouten,\\
  Johan T. den Dunnen, Peter E.M. Taschner
  \vspace{10pt}\\
  Department of Human Genetics\\
  Center for Human and Clinical Genetics\\
  \texttt{j.f.j.laros@lumc.nl}}
\date{\today}
%\setlength{\parindent}{0pt}

\begin{document}

\maketitle

\begin{abstract} \noindent
\end{abstract}

\section{Introduction}\label{introduction}
\cite{Mutalyzer}
\cite{HGVS}

\begin{verbatim}
- Currently GenBank and LRG reference supported.
- Any organism, including translation.
- Phased variants, of all genes containing variants, half of
  them have more than one.
\end{verbatim}

\section{Materials and Methods}
The suite is logically divided in modules which, combined make up several
interfaces.

\begin{table}[]
  \caption{Modules.}
  \label{tab:modules}
  \begin{center}
    \begin{tabular}{l|l}
      name           & function\\
      \hline
      HGVS parser    & Check the HGVS syntax.\\
      Retriever      & Retrieve a reference sequence.\\
      Cross\-mapper    & Convert positions from \texttt{g.} to \texttt{n.} or
        \texttt{c.} and vice versa.\\
      Database       & Interface to Mutalyzer's internal database.\\
      Mutator        & Apply variants to a reference sequence.\\
      GenRecord      & Generalisation of reference sequences.\\
    \end{tabular}
  \end{center}
\end{table}

A list of core modules of the Mutalyzer suite is shown in
Table~\ref{tab:modules}, the functionality of each module is described in the
following sections.

\subsubsection{HGVS parser} \label{subsubsec:parser}
The formalisation of the HGVS nomenclature~\cite{hgvs_bnf}, made it possible to
implement a context free grammar parser that encompasses the complete
nomenclature, including nesting and other newly added features. The
\emph{parser} module is the implementation of this context free parser. The
major functionalities of this module are recognising all syntactically valid
descriptions and generating a \emph{parse tree}, which is used to interpret the
variant description.

\subsubsection{Retriever} \label{subsubsec:retriever}
To verify the validity of variant descriptions, the reference sequence file on
which the variant is described is needed. Reference sequence files contain the
reference sequence and annotation about transcripts, CDSs, exons, etc. These
reference sequences are retrieved from either the NCBI (for GenBank files) or
the EBI (in case of LRG files). The \emph{retriever} module is responsible for
the communication with these repositories, as well as local administration of
downloaded files.

For performance reasons, reference sequences are stored in a cache that resides
on the server that Mutalyzer runs on. Administration of the cache is done by
the \emph{database module} described in Section~\ref{subsubsec:db}.

\subsubsection{Cross\-mapper} \label{subsubsec:crossmap}
The HGVS nomenclature has different \emph{positioning systems} (\texttt{g.},
\texttt{c.}, etc.), the non-trivial conversion between these systems is done by
the \emph{cross\-mapper} module. By facilitating the bidirectional conversion
from \texttt{c.} and \texttt{n.} to \texttt{g.} and \texttt{m.}, this module
can be used to convert positions between transcripts.


\begin{table}[]
  \caption{Different representations of an intronic variant of C11orf57.}
  \label{tab:crossmap}
  \begin{center}
    \begin{tabular}{l|l}
      type & description\\
      \hline
      genomic     & \texttt{UD\_135074263017:g.8000del}\\
      chromosomal & \texttt{NC\_000011.9:g.111949587del}\\
      transcript  & \texttt{UD\_135074263017(PIH1D2\_v001):c.-4915del}\\
      transcript  & \texttt{UD\_135074263017(C11orf57\_v001):c.170+548del}\\
      transcript  & \texttt{UD\_135074263017(TIMM8B\_v001):c.*6432del}\\
      transcript  & \texttt{UD\_135074263017(TIMM8B\_v002):n.*5937del}\\
      transcript  & \texttt{UD\_135074263017(SDHD\_v001):c.-8045del}\\
    \end{tabular}
  \end{center}
\end{table}

In Table~\ref{tab:crossmap} we see an example of the capabilities of the
cross\-mapper. A variant described on one of the transcripts (C11orf57\_v001
for example), is converted to a genomic one and subsequently converted to
descriptions on all other annotated transcripts in the reference sequence file.

\subsubsection{Database} \label{subsubsec:db}
Since much of the retrieved information is reusable and quite some
administration of different datasets needs to be done, Mutalyzer uses a
database to store mapping and linking information and its own administration
of local files.

To facilitate the conversion of chromosomal coordinates to gene-oriented ones,
a number of \emph{mapping databases} were created. These databases contain the
locations of all exons of all transcripts, together with the coordinates of the
CDS. With this information the Mutalyzer Crossmapper module (described in
Section~\ref{subsubsec:crossmap} can convert all descriptions on transcripts
(\texttt{NM}) to chromosomal ones and vice versa.

For various reasons, discussed in Section~\ref{subsubsec:genrecord}, the link
between a transcript and a protein accession number needs to be known, e.g.,
the product of \texttt{NM\_000193.2} is \texttt{NP\_000184.1}. This link is
retrieved from the NCBI and for performance reasons they are stored in the
database.

When placing a reference sequence in the cache, the md5sum of the file is
calculated and stored in the database, together with information about its
source. If the reference sequence is a slice of a chromosome or contig, the
parameters used to make this slice are stored. For other methods of uploading
all information necessary to retrieve the reference sequences once it is
removed from the cache is stored. This way of cache administration also
prevents re-uploading of reference sequences that are already known to
Mutalyzer, so in principle no reference sequence will be stored under different
accession numbers.

When clients submit a batch job to the \emph{batch queueing system}, described
in Section~\ref{subsec:batch}, all necessary information about the job, as well
als the content of the job itself, is stored in the database. Every client is
assigned to their private queue and tasks are selected from these queues in a
round-robin way. This approach guarantees that a small job will finish in a
short amount of time, regardless of the size of other scheduled jobs (only
depending on the amount of scheduled jobs).

\subsubsection{Mutator}
In order to perform any contextual checks, the retrieved reference sequence
must be modified to assess the validity of a variant description. To facilitate
the correction of ill formed but interpretable descriptions, a simulation of
the variant is made by the \emph{mutator} module. By tracking the position
shifts resulting from the simulation of partial variants an allele description
can be simulated.

\subsubsection{GenRecord} \label{subsubsec:genrecord}
In order to be able to work with different types of reference sequences
(GenBank, LRG, EMBL, \ldots), an abstraction of reference sequence files is
needed. The \emph{Genrecord} module is an implementation of such an
abstraction.

Since the annotation if the various reference sequence files are not strict,
multiple annotation enrichment schemes are needed to standardise the
information contained in them. The reference sequence annotation enrichment
consists mainly of the linking of annotated transcripts a \emph{coding
sequence} (CDS) and protein. In many cases, (especially in GenBank files) there
is no direct link between a transcript and its CDS, making it impossible to
reconstruct the layout of the transcript and thereby the biological effect of a
variant. Therefore an extensive set of methods is developed to find this link.

For each transcript we find all CDSs that are consistent with the transcript in
question, this can be considered as quality control of the annotation. In
general this does not uniquely assign a CDS to a transcript but it does narrow
down the number of possibilities. A link between the annotated mRNA and protein
accession numbers as described in Section~\ref{subsubsec:db} is a reliable way
of resolving ambiguities, so usage of this information is preferred when
available. An other reliable, but frequently missing, way of linking mRNA to a
CDS is by using the \emph{locus} tag.

As a last resort, the product tags of both mRNA and CDS may be used, for the
set of CDSs, we determine the longest common prefix and suffix to find the
consecutive words that are not shared between all product tags. We do the same
for the set of transcripts. If these operations lead to a list that uniquely
identifies the transcripts and CDSs, we proceed to match the two lists.

\begin{table}[]
  \caption{Usage of the product tag.}
  \label{tab:product}
  \begin{center}
    \begin{tabular}{lll}
      Type & Accession number & Product\\
      \hline
      CDS  & \texttt{NM\_000109.3} & dystrophin, transcript variant Dp427c
        protein\\
      CDS  & \texttt{NM\_004006.2} & dystrophin, transcript variant Dp427m
        protein\\
      CDS  & \texttt{NM\_004009.3} & dystrophin, transcript variant Dp427p1
        protein\\
      mRNA & \texttt{NP\_000100.2} & dystrophin Dp427c isoform protein\\
      mRNA & \texttt{NP\_003997.1} & dystrophin Dp427m isoform protein\\
      mRNA & \texttt{NP\_004000.1} & dystrophin Dp427p1 isoform protein\\
    \end{tabular}
  \end{center}
\end{table}

Consider the example in Table~\ref{tab:product}, the identifying words in the
set of CDSs are Dp427c, Dp427m and Dp427p1. The same words are found in the set
of transcripts so this information can be used to resolve ambiguity.

The methods described in this section are tried in order and the method that
finally resolved the ambiguity is reported by Mutalyzer.

\subsection{Name Checker} \label{subsec:namecheck}
Although the contextual checks have not been implemented for the complete
nomenclature, the recognition of allele descriptions has been implemented.
These descriptions are, apart from simple variants consisting of one change,
the most occurring ones. With allele descriptions one can describe a large
number of changes, i.e., all descriptions that need no information from outside
the reference sequence.

We define a \emph{raw variant} as an elementary variant, e.g., a substitution,
deletion, insertion, etc. An \emph{allele description} is obtained by
concatenation of raw variants. Consider the following description
\begin{center}
  \texttt{NM\_002001.2:c.[10del;22C>T;101\_119inv]}
\end{center}
The part between brackets is
the allele description, which consists of raw variants (\texttt{10del},
\texttt{22C>T} and \texttt{101\_119inv}) separated by a semicolon.

After the description is parsed, the \emph{reference sequence}, uniquely
identified by the accession number, which is part of the description, is
retrieved from a reference sequence repository (e.g., the NCBI~\cite{NCBI} or
the EBI). The reference sequence (in either GenBank or LRG format) is then
parsed and any missing data (described in Section~\ref{subsubsec:genrecord}) is
retrieved to prepare for the next step.

With the parsed variant description and the information from the reference
sequence, the variation can be simulated to obtain the observed sequence. In
this simulation all raw variants are visualised and checked. The checks on the
raw variants is extensive.

Before any disambiguation is performed, the validity of each raw variant is
checked, this includes the verification of optional arguments, like the
superfluous indication of a deleted sequence in \texttt{10\_12delAAT}.
Mutalyzer checks whether the reference sequence indeed contains the sequence
\texttt{AAT} at the indicated position. An other optional argument check is the
verification of the length of a range (\texttt{3\_9del7}).

After the input checks, the disambiguation is performed. First, Mutalyzer
checks whether the minimal description is used. In case of a \texttt{delins},
one can for example add reference bases to the inserted sequence, adding no
information to the description. If, for example, the reference sequence is
\texttt{AACGTAA}, we can define the following deletion-insertion:
\texttt{3\_4delinsTT}, resulting in an observed sequence of \texttt{AATTTAA}.
The same result will be obtained if we define the variant as
\texttt{2\_6delinsATTTA}. This latter description can be minimised by
calculating and removing the \emph{longest common prefix} and the \emph{longest
common suffix} of the deleted and the inserted sequence.

In case of an inversion, a prefix of the inversion can be the reverse
complement of its suffix, i.e., a \emph{partial palindrome}. The
description of an inversion is minimised in a similar way as described above.

\begin{table}
  \caption{Disambiguation of raw variant types.}
  \label{tab:typedisambiguation}
  \begin{center}
    \begin{tabular}{l|l}
      type            & simplification\\
      \hline
      \texttt{delins} & \texttt{del}, \texttt{ins}, \texttt{subst},
        \texttt{inv}, \texttt{dup}\\
      \texttt{ins}    & \texttt{dup}\\
      \texttt{inv}    & \texttt{subst}
    \end{tabular}
  \end{center}
\end{table}

After the minimisation step, a disambiguation scheme is used to check whether
the type of the raw variant is correct. In Table~\ref{tab:typedisambiguation}
it is shown which variant types can possibly be written as a simpler type.

Finally, a deletion or insertion is shifted to the most 3' position possible.
We use a \emph{rolling} algorithm that takes circular permutations of the
deleted  or inserted sequence into account. If for example, we insert the
sequence \texttt{TCCA} in a reference sequence \texttt{CATC}, the
algorithm will correct the description \texttt{2\_3insTCCA} to
\texttt{3\_4insCCAT}. Note that this method works for both the forward as well
as the reverse strand, so if a gene resides on the reverse strand, the position
will be shifted in the opposite direction of that of the genomic one.
Furthermore, if an insertion or a deletion is described on a transcript, the
position will not be shifted over a splice site.

After the simulation of the variation, we have the observed sequence. We use
this observed sequence to do basic effect prediction.

For all the annotated transcripts in the reference sequence, the corrected
variant description is shown, as well as a list of protein descriptions. Each
of the DNA variant descriptions can be selected for a more detailed analysis.
In the detailed analysis the reference protein and the variant protein is
visualised and the area of change is highlighted. For the selected transcript,
a list of exon start and end positions are given, as well as the CDS start and
end positions.

For all raw variants, effects on restriction sites are calculated. A table is
generated that contains the number of the raw variant, a list of removed
restriction sites and a list of added restriction sites.

\begin{verbatim}
Martijn:
- Deletion of exons as well as partial exons (resulting in a
  fusion exon) is supported.
- Gives informative warnings when a variant is near a splice site.
- Supports ``fuzzy'' positions.
\end{verbatim}

Effect prediction becomes more complex when variants are located close to or
overlapping splice sites.
Barring some specific cases, Mutalyzer takes a safe approach and issues a
warning and does not predict a translated protein if a splice site is hit
(example: \texttt{NG\_012772.3(BRCA2):c.508\_516+9del}).
However, a deletion partly covering two exons (thereby spanning the intron),
although affecting two splice sites, is considered as a case where protein
prediction can still be valuable.
An example is \texttt{NG\_012772.3(BRCA2):c.508\_525del}, where the deletion
is interpreted as forming a fusion exon (in-frame).
As another example, consider the large deletion
\texttt{NG\_012772.3(BRCA2):c.317-10\_631+14del} covering 4 complete exons.
Mutalyzer removes the exons from the CDS, which is still in-frame, in order to
give a meaningful protein prediction.
In practice, similar large deletions are often identified without their
precise break points which can be described using fuzzy intronic offsets (in
this case \texttt{NG\_012772.3(BRCA2):c.317-?\_631+?del}).
Internally and for crossmapping to \texttt{g.} descriptions, Mutalyzer
interprets these offsets as the center of the intron.

\subsection{Syntax Checker} \label{subsec:syntaxcheck}
If no reference sequence is available, or if large quantities of
descriptions in a small amount of time need to be checked, it might be
desirable to only check the syntax. The \emph{Syntax Checker} is an interface
to the HGVS parser, which will return whether or not the syntax of a variant
description is correct. No contextual check is performed. Since there is no
communication with reference sequence repositories, this check is extremely
quick.

\subsection{Position Converter} \label{subsec:positionconvert}
The \emph{position converter} is an interface to the HGVS parser, the
cross\-mapper and the database. With this interface, we can convert a
description that uses a RefSeq transcript as reference sequence to a
description on a chromosomal reference sequence and vice versa. The mapping
information is retrieved daily from the NCBI. Currently Human genome build 18
and 19 are supported.

This interface can be used to quickly convert variants found by a high
throughput screening, e.g., an NGS experiment. This enables people to annotate
their NGS experiments with informative HGVS descriptions. An other use of this
interface is to convert (lift over) a description from one transcript to an
other, or to transcripts of other (overlapping) genes. Finally, by using
transcripts that are mapped to both hg18 as well as to hg19, we can convert a
chromosomal description from one build to an other. Potentially, descriptions
can be lifted over to other species, provided cross-species transcript
annotation is available.

\subsection{SNP Converter} \label{subsec:snpconvert}
For converting a DbSNP~\cite{DBSNP} id to an HGVS description, the \emph{SNP
converter} can be used. This interface retrieves the annotated HGVS
descriptions from the NCBI.

\subsection{Name Generator}
\begin{verbatim}
Gerben:
- Educational interface for those who are not familiar with
  the HGVS nomenclature.
- Constructed variant description can be checked (clickable)
  with the name checker.
\end{verbatim}

\subsection{Reference File Loader}
To support reference sequences unknown to the NCBI or EBI, we implemented a
\emph{reference file loader}. This interface can be used to upload a local
file, upload a file by supplying an URL, or to slice a chromosome or contig.

A slice can be made directly by supplying the name or accession number of a
chromosome or contig, the location of the slice and the orientation.
Additionally, a gene name in combination with the name of an organism can be
used to select the slice automatically. In this mode, the most recent build of
the organism in question will be used, the orientation is selected
automatically, the size of the flanking regions (5' and 3') can be modified.

Administration of the uploaded or sliced reference sequences is handled by the
database module, described in Section~\ref{subsubsec:db}.

\subsection{Batch Jobs} \label{subsec:batch}
To process large batches of data in a non-interacive way, we have developed the
\emph{batch checker}. This interface is available for the \emph{Name Checker},
the \emph{Syntax Checker}, the \emph{Position Converter} and the
\emph{SNP Converter} (see
Sections~\ref{subsec:namecheck},~\ref{subsec:syntaxcheck},~\ref{subsec:positionconvert} and~\ref{subsec:snpconvert} respectively).

The Batch Checker accepts three types of input formats: CSV files (the
delimiters are detected automatically), Microsoft Excel files and OpenOffice
ODS files. Each row consists of a variable number of fields, where every field
contains a single variant description (or dbSNP rs number in case of the SNP
Converter). For backwards compatibility, the format used by Mutalyzer~1.0.3 is
also accepted.

The output of a Mutalyzer Batch run is a tab delimited CSV file, which has a
header-row to clarify the results. We recommend opening the file in a
spreadsheet program, such as OpenOffice Calc or Microsoft Excel. Note that
empty lines are removed from the batch input file. For a complete description
of the output fields of the various batch checker modules, see
Tables~\ref{tab:namecheckbatch},~\ref{tab:syntaxcheckbatch},~\ref{tab:positionconvertbatch}~and~\ref{tab:snpconvertbatch}.

Batch jobs are interleaved, so that even if large jobs are submitted, small
jobs will still finish in a short amount of time, the scheduling method is
described in Section~\ref{subsubsec:db}. The scheduler is designed in such a
way that it can be stopped for maintenance. Even when an unplanned downtime
occurs, the scheduler will resume where it was stopped, without missing
anything in the output.

\subsection{Webservices}
To facilitate developers that want to use the Mutalyzer functionality, we have
developed a large number of webservices
\footnote{\texttt{https://mutalyzer.nl/webservices}}. Currently two major
protocols are supported: SOAP~\cite{SOAP} and
JSON-RPC~over~HTTP~\cite{JSON-RPC}.

See Section~\ref{sec:webservices} for a full list of implemented functions.
There is an online description available for the API. On this page, there are
also example clients available.

\begin{verbatim}
- Someone made a java client? Perhaps add link?
\end{verbatim}

\subsection{Feedback}
For feature requests, documentation and error reporting, we use the
Trac~\cite{TRAC} system. Users can either register themselves when they submit
a request, or they can do so anonymously. If registration was chosen, the user
will be automatically informed of changes.

\section{LOVD~3.0}
\begin{verbatim}
Uses the Mutalyzer 2.0 Webservices for:
- Retrieving a reference sequence (add new gene).
- Mapping descriptions.
- Converting descriptions to other transcripts.
- Checking variant descriptions.
\end{verbatim}

\section{Conclusions and further research}\label{conclusion}
\begin{verbatim}
- EMBL reference sequences.
- Nesting.
\end{verbatim}

\subsection{Experimental description extractor}
\begin{verbatim}
Generates a description from two sequences.
- Use after applying a variant in the Name Checker.
- Compare two reference sequences.

Will solve the combining and splitting of variants problem. True
disambiguation.
\end{verbatim}

\bibliography{$HOME/projects/bibliography}{}
\bibliographystyle{plain}

\appendix

\section{Webservices} \label{sec:webservices}
\LTXtable{\textwidth}{webservices.tex}

\section{Batch output} \label{sec:batchoutput}
\begin{table}[h]
  \caption{Name Checker batch output.}
  \label{tab:namecheckbatch}
  \begin{center}
    \begin{tabular}{l|l}
      name                             & description\\
      \hline
      Input                            & User input.\\
      Errors | Messages                & List of errors and warnings.\\
      AccNo                            & Accession number from the input.\\
      Genesymbol                       & Gene symbol from the input.\\
      Variant                          & Variant description.\\
      Reference Sequence Start Descr.  & Description in \texttt{g.} or
        \texttt{n.} notation.\\
      Coding DNA Descr.                & Description in \texttt{c.} notation.\\
      Protein Descr.                   & Description of the protein change.\\
      GeneSymbol Coding DNA Descr.     & Description in \texttt{c.} notation
        including the gene symbol.\\
      GeneSymbol Protein Descr.        & Description of the protein change
        inclusing the gene symbol.\\
      Genomic Reference                & ??\\
      Coding Reference                 & Reference sequence of the
        transcript.\\
      Protein Reference                & Reference sequence of the protein.\\
      Affected Transcripts             & List of affected transcripts.\\
      Affected Proteins                & List of affected proteins.\\
      Restriction Sites Created        & List of created restriction sites.\\
      Restriction Sites Deleted        & List of deleted restriction sites.\\
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[h]
  \caption{Syntax Checker batch output.}
  \label{tab:syntaxcheckbatch}
  \begin{center}
    \begin{tabular}{l|l}
      name   & description\\
      \hline
      Input  & User input.\\
      Status & Either ``OK'' or an error message.\\
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[h]
  \caption{Position Converter batch output.}
  \label{tab:positionconvertbatch}
  \begin{center}
    \begin{tabular}{l|l}
      name                & description\\
      \hline
      Input Variant       & User input.\\
      Errors              & List of errors and warnings.\\
      Chromosomal Variant & Variant in \texttt{g.} notation.\\
      Coding Variant(s)   & Variant in \texttt{c.} notation.\\
    \end{tabular}
  \end{center}
\end{table}

\begin{table}[h]
  \caption{Position Converter batch output.}
  \label{tab:snpconvertbatch}
  \begin{center}
    \begin{tabular}{l|l}
      name                & description\\
      \hline
      Input Variant       & User input.\\
      HGVS description(s) & List of HGVS descriptions.\\
      Errors | Messages   & List of errors and warnings.\\
    \end{tabular}
  \end{center}
\end{table}
%\section{Annotation enrichment} \label{sec:enrichment}

\end{document}
