% Alter these four lines for a new presentation.
\providecommand{\me}{Jeroen F. J. Laros}
\providecommand{\myTitle}{Parsing the HGVS nomenclature}
\providecommand{\myConference}{Work discussion}
\providecommand{\myDate}{Wednesday, 16 September 2009}

% Now go to %%% BEGIN PRESENTATION %%%

\documentclass[a4, portrait]{seminar}

\usepackage{semcolor} % For coloured text.
\usepackage{slidesec} % For section headings.
\usepackage{newcent}  % This is a better font for presentations.
\usepackage{gastex}
\input{seminar.bug}

\usepackage{graphicx} % For pictures.
\usepackage{fancybox} % For the background picture.

\definecolor{Blue}{rgb}{0.,0.11372,0.37647} % Custom LUMC color

\renewcommand{\labelitemi}{\textcolor{white}{$\bullet$}}
\renewcommand{\labelitemii}{\textcolor{white}{--}}
\renewcommand{\labelitemiii}{\textcolor{white}{$\ast$}}
\renewcommand{\labelitemiv}{\textcolor{white}{$\circ$}}

\providecommand{\mspace}{\vspace{0.5cm}}

\newslideframe{TITLE}{ % Template for the title.
  \boxput{
    \rput(0, 0){\includegraphics[angle=90, scale=.485]{bg}}
  }{#1}
}

\newslideframe{PRES}{ % Template for the body.
  \boxput{
    \rput(0, 0){\includegraphics[angle=90, scale=.485]{bg2}}
  }{
    \textcolor{Blue}{
    \rput[l]{90}(8.57, -1.5){\scriptsize{\myConference}} 
    \rput[c]{90}(8.57, 5.35){\scriptsize{\theslide/\pageref{LastPage}}}
    \rput[r]{90}(8.57, 12.2){\scriptsize{\myDate}}
    }
    \white #1
  }
}

\renewcommand{\makeslideheading}[1]{ % Put the slide headings on top.
  \rput[l](0.2, .40){
      \textbf{
        \textcolor{Blue}{#1}
    }
  }
  \newline
}

\pagestyle{empty}

\begin{document}

\slideframe{TITLE} % Use the title template.

\begin{slide}
\setcounter{slide}{0}
\vspace*{1.5cm}
\begin{center}
{\bf\Large{\myTitle}}\\
\vspace{2.5cm}
\textcolor{Blue}{
  {\bf
    \small{\me}\\
    \small{Department of Human Genetics}\\
    \small{Center for Human and Clinical Genetics}
  }
}
\end{center}
\vfill
\end{slide}

\slideframe{PRES} % Use the body template.

%%% BEGIN PRESENTATION %%%

\begin{slide}
\slideheading{HGVS nomenclature}

HGVS stands for Human Genome Variation Society. 
\mspace

Nomenclature for the description of sequence variations.
\mspace

Used as input for Mutalyzer, a program running on a web server that checks
the correctness of a variation.

\begin{itemize}
\item To assist people in denoting a variation.
\item To check already stored variations (in LOVD for example).
\item To analyse the effect of a mutation.
\item etc.
\end{itemize}
\vfill
\end{slide}

\begin{slide}
\slideheading{Variation checking}

Must be done on two levels:

\begin{itemize}
\item Syntactic checking.
\item Semantic checking.
\end{itemize}
\mspace

Syntactic checking is to check whether the variation is correct (in~principle):
\begin{itemize}
\item Is the reference sequence given?
\item If a gene symbol is given, is it between parenthesis?
\item If a transcript variant is given, is it preceded by ``\_v''?
\item etc.
\end{itemize}
\vfill
\end{slide}

\begin{slide}
\slideheading{Variation checking}

Semantic checking is to check whether the variation is also correct within the 
context.
\begin{itemize}
\item If a substitution ``A$>$T'' is given at a certain position, is there
      really an ``A'' in the reference sequence?
\item Are two adjacent deletions given? (if so, we have to group them).
\item A large delins is given, might it be an inversion?
\item etc.
\end{itemize}
\mspace

Semantic checking can only be done after the syntactic check.
\vfill
\end{slide}

\begin{slide}
\slideheading{The problem}

The HGVS nomenclature is capable of describing many different variations:
\mspace

One simple variation.\\
{\bf NG\_008660.1(CAPN3):c.496delC}
\mspace

More simple variations on one allele.\\
{\bf NG\_008660.1(CAPN3):c.[496delC;500G$>$T;510A$>$C]}
\mspace

A simple insertion.\\
{\bf NG\_008660.1(CAPN3):c.496\_497insAGGGACT}
\vfill
\end{slide}

\begin{slide}
\slideheading{The problem}

The variations can become complex:
\mspace

An insertion of a slice of an other accession number.\\
{\bf NG\_008660.1(CAPN3):c.496\_497insNM\_000059:n.4\_104}
\mspace

The same insertion as above, but now with a variation within the insertion.\\
{\bf NG\_008660.1(CAPN3):c.496\_497insNM\_000059:n.4\_104\{100G$>$A\}}
\mspace

\hbox{These expressions can become of arbitrary length (and complexity).}
\vfill
\end{slide}

\begin{slide}
\slideheading{The problem}

We want to extract the data from the input string in two steps:
\begin{itemize}
\item Recognition of an input string.
      \begin{itemize}
      \item Optionally we can give information upon rejection.
      \end{itemize}
\item Extraction of data from the input string into a format the computer can
      understand (a parse tree).
      \begin{itemize}
      \item This parse tree is used in combination with the context for 
            semantic checking.
      \end{itemize}
\end{itemize}
\mspace

For these two functions, we need a \emph{parser}.
\vfill
\end{slide}

\begin{slide}
\slideheading{Two functions of a parser}

Syntactic checking:
\mspace

First of all, we want a yes/no answer to see if the input is valid.

\begin{center}
\begin{picture}(80,20)(0,5)
  \gasset{Nadjust=w,linecolor=white}
  \node[Nmarks=i](A)(0,10){Start}
  \node[dash={1}0](B)(40,10){Is Valid?}
  \node[Nmarks=r](C)(80,20){Reject}
  \node[Nmarks=r](D)(80,0){Accept}
  \drawedge(A,B){Parsing}
  \drawedge(B,C){No}
  \drawedge[ELside=r](B,D){Yes}
\end{picture}
\end{center}
\mspace

{\bf NG\_008660.1(CAPN3):c.496delC} $\rightarrow$ Yes.

{\bf NG\_008660.1(CAPN3)c.496delC} $\rightarrow$ No. 
\vfill
\end{slide}

\begin{slide}
\slideheading{Two functions of a parser}
{\bf NG\_008660.1(CAPN3):c.496delC} $\rightarrow$ Yes.\\
\fbox{\parbox{7cm}{
Accession Number: NG\_008660 (version 1)\\
Gene: CAPN3\\
Reference type: coding\\
Mutation:\\
- Position: 496\\
- Type: deletion
}}
\mspace

\begin{center}
\begin{picture}(85,10)(0,0)
  \gasset{Nadjust=w,linecolor=white}
  \node[Nmarks=i](A)(0,5){Start}
  \node[dash={1}0](B)(30,5){Is Valid?}
  \node(C)(60,10){Give reasons}
  \node(D)(60,0){Build result}

  \node[Nmarks=r](E)(85,10){Reject}
  \node[Nmarks=r](F)(85,0){Accept}

  \drawedge(A,B){Parsing}
  \drawedge(B,C){No}
  \drawedge[ELside=r](B,D){Yes}
  \drawedge(C,E){}
  \drawedge(D,F){}
\end{picture}
\end{center}
\mspace

{\bf NG\_008660.1(CAPN3)c.496delC} $\rightarrow$ No.\\
\fbox{\parbox{7cm}{Reason: Missing `:'}}
\vfill
\end{slide}

\begin{slide}
\slideheading{What kind of parser?}
\vspace{-1cm}
\begin{center}
\scalebox{1}{
\hspace{3.4cm} \input{Chomsky.pstex_t}
}
\end{center}
\vspace{-3cm}
\begin{itemize}
\item Type-$3$: Regular.
\item Type-$2$: Context-free.
\item Type-$1$: Context-sensitive.
\item Type-$0$: Recursively enumerable.
\end{itemize}
\vfill
\end{slide}

\begin{slide}
\slideheading{Type-$3$ parsers}

Regular expressions, capable of recognising strings of unbounded length, 
for example, the string $aaa$ and the string $aaaaaaaaaa$ are both recognised
by the regular expression $a^*$.

\begin{center}
\begin{picture}(20,30)(0,5)
  \gasset{linecolor=white}
  \node[Nmarks=ir](A)(10,15){}
  \drawloop(A){$a$}
\end{picture}
\end{center}

Regular expressions can be visualised as finite automata, the graph depicted
above is such an automaton.

\vfill
\end{slide}

\begin{slide}
\slideheading{Type-$3$ parsers}

Though regular expressions can recognise complicated strings (pattern
matching), they are incapable of ``counting'' (the string $a^nb^n$ can not be
recognised for each $n$).

\begin{center}
\begin{picture}(60,10)(0,5)
  \put(70,10){$a^1b^1$}
  \gasset{linecolor=white}
  \node[Nmarks=i](A)(0,10){}
  \node(B)(30,10){}
  \node[Nmarks=r](C)(60,10){}
  \drawedge(A,B){$a$}
  \drawedge(B,C){$b$}
\end{picture}
\end{center}

\begin{center}
\begin{picture}(60,20)(0,5)
  \put(70,10){$a^1b^1$ {\bf or} $a^2b^2$}
  \gasset{linecolor=white}
  \node[Nmarks=i](A)(0,10){}
  \node(B)(15,10){}
  \node(C)(30,10){}
  \node(D)(45,10){}
  \node[Nmarks=r](E)(60,10){}
  \node(F)(30,20){}
  \drawedge[ELside=r](A,B){$a$}
  \drawedge[ELside=r](B,C){$a$}
  \drawedge[ELside=r](C,D){$b$}
  \drawedge[ELside=r](D,E){$b$}
  \drawedge(A,F){$a$}
  \drawedge(F,E){$b$}
\end{picture}
\end{center}

This limitation disqualifies this class of languages when we want to use nested
expressions.
\vfill
\end{slide}

\begin{slide}
\slideheading{Type-$2$ parsers}

These parsers are commonly used in compilers and interpreters of programming 
languages, e.g., Perl, C, Java, etc.
\mspace

The restriction for these types of parsers is that the language is
context-free.
\mspace

Because of the nesting, the HGVS nomenclature is actually a context-free
language. So we need a parser of this type to interpret the given string.
\vfill
\end{slide}

\begin{slide}
\slideheading{An other problem}

The nomenclature is not static (yet).
\mspace

Because of this, we shall need frequent alterations in our parser, to reflect
the newly added (or deleted) rules.
\mspace

We need a way to make the rules insightful.
\vfill
\end{slide}

\begin{slide}
\slideheading{Example: A calculator}

Suppose we want to parse the input of a calculator that is capable of using
variables:

$a = 1$\\
$b = 3$\\
$c = a * 2$\\
$d = b / c$\\

Somehow, we need to catch these expressions in general rules.
\vfill
\end{slide}

\begin{slide}
\slideheading{Example: A calculator}

\begin{tabular}{lll}
integer & $\rightarrow$ & \ldots $|$ -$2$ $|$ -$1$ $|$ $0$ $|$ $1$ $|$ 
                          $2$ $|$ \ldots\\
varname & $\rightarrow$ & $a$ $|$ $b$ $|$ $c$ $|$ \ldots $|$ $z$\\
equals & $\rightarrow$ & $=$\\
operator & $\rightarrow$ & $+$ $|$ $-$ $|$ $*$ $|$ $/$\\
operand & $\rightarrow$ & integer $|$ varname\\
unaryoperation & $\rightarrow$ & operand\\
binaryoperation & $\rightarrow$ & operand operator operand\\
operation & $\rightarrow$ & unaryoperation $|$ binaryoperation\\
expression & $\rightarrow$ & varname equals operation\\
\end{tabular}
\mspace

This notation is BNF, short for Backus-Naur Form.\\
(`$|$' means `or').
\vfill
\end{slide}

\begin{slide}
\slideheading{The nomenclature rules (a sample)}

\begin{tabular}{lll}
Ref & $\rightarrow$ & ((RefSeqAcc $|$ GeneSymbol) `:')? RefType?\\
Extent & $\rightarrow$ & PtLoc `\_' (`o'? (RefSeqAcc $|$ GeneSymbol) `:')? PtLoc\\
RangeLoc & $\rightarrow$ & Extent $|$ `(` Extent `)'\\
Loc & $\rightarrow$ & PtLoc $|$ RangeLoc\\
FarLoc & $\rightarrow$ & (RefSeqAcc $|$ GeneSymbol) (`:' RefType? Extent)? \\
Subst & $\rightarrow$ & PtLoc Nt `$>$' Nt\\
Del & $\rightarrow$ & Loc `del' (Nt$^+$ $|$ Number)?\\
Dup & $\rightarrow$ & Loc `dup' (Nt$^+$ $|$ Number)? Nest?\\
AbrSSR & $\rightarrow$ & PtLoc  Nt$^+$ `(' Number `\_' Number `)'\\
VarSSR & $\rightarrow$ & (PtLoc  Nt$^+$ `[' Number `]') $|$ (RangeLoc `[' Number `]') \\
\end{tabular}
\vfill
\end{slide}

\begin{slide}
\slideheading{Avoid ambiguity}

If there are more than one paths to evaluate an expression, the language is 
ambiguous, so it might mean more than one thing.

Note that more than one expression for the same thing {\bf is} allowed.
\mspace

Ambiguous languages can not be parsed by a Type-$2$ parser any more (and they
are difficult to interpret for humans as well).
\mspace

We were forced to made a couple of changes to the nomenclature to avoid this
problem. 
\vfill
\end{slide}

\begin{slide}
\slideheading{Translation to code}

Fortunately, since there are many programming languages and new programming
languages are developed each day, there are tools available to generate a 
parser, once the language has been defined.
\mspace

Parser generators make a programmer able to use the language definition
(BNF) almost directly as code. This makes the code highly flexible and 
maintainable.
\vfill
\end{slide}

\begin{slide}
\slideheading{Translation to code}
\begin{verbatim}
Ref = Optional((RefSeqAcc ^ GeneSymbol) + Suppress(':')) + 
      Optional(RefType)
Extent = Group(PtLoc("PtLoc"))("StartLoc") + 
         Suppress('_') + Group(Optional(Group(Optional('o') 
         + (RefSeqAcc ^ GeneSymbol) + Suppress(':') + 
         Optional(RefType)))("OptRef") + 
         PtLoc("PtLoc"))("EndLoc")
RangeLoc = Extent ^ (Suppress('(') + Extent + 
           Suppress(')'))
Loc = Group(PtLoc("PtLoc"))("StartLoc") ^ RangeLoc
FarLoc = (RefSeqAcc ^ GeneSymbol) + Optional(Suppress(':') 
         + Optional(RefType) + Extent)
Subst = Group(PtLoc("PtLoc"))("StartLoc") +
        Nt + Literal('>')("MutationType") + Nt
\end{verbatim}
\vfill
\end{slide}

\begin{slide}
\slideheading{The parser as an acceptor}
\begin{verbatim}
> Parser "NG_008660.1(CAPN3):c.[496delC"
Error: Expected "]" (at char 29), (line:1, col:30)
NG_008660.1(CAPN3):c.[496delC
                             ^
\end{verbatim}
\vspace{-.5cm}
\textcolor{yellow}{\tt{NG\underline{\ }008660.1(CAPN3):c.[496delC]}}
\mspace

\begin{verbatim}
> Parser "NG_008660.1(CAPN3_v1)c.496delC"
NG_008660.1(CAPN3_v1)c.496delC
Error: Expected ":" (at char 21), (line:1, col:22)
NG_008660.1(CAPN3_v1)c.496delC
                     ^
\end{verbatim}
\vspace{-.5cm}
\textcolor{yellow}{\tt{NG\underline{\ }008660.1(CAPN3\underline{\ }v1):c.496delC}}
\vfill
\end{slide}

\begin{slide}
\slideheading{The parse tree}
\begin{verbatim}
> Parse "NG_008660.1(CAPN3_v1):c.[496delC;500A>T]"
\end{verbatim}

\begin{center}
\fbox{
\begin{minipage}{0.6\textwidth}
\vspace{-.2cm}
\tt{
\begin{tabular}{ll}
RefSeqAcc: & NG\underline{\ }008660\\
RefType: & c\\
Version: & 1\\
Gene Symbol: & CAPN3\\
Transcript variant: & 1
\vspace{-.2cm}
\end{tabular}
}
\end{minipage}
}
\end{center}

\begin{figure}
\fbox{
\begin{minipage}{0.4\textwidth}
\vspace{-.2cm}
\tt{
\begin{tabular}{ll}
\multicolumn{2}{c}{RawVar}\\
- Position: & 496\\
- Type: & del\\
 & \\
\vspace{-.2cm}
\end{tabular}
}
\end{minipage}
}
\hfill
\fbox{
\begin{minipage}{0.4\textwidth}
\vspace{-.2cm}
\tt{
\begin{tabular}{ll}
\multicolumn{2}{c}{RawVar}\\
- Position: & 500\\
- Type: & $>$\\
- From: & A\\
- To: & T
\vspace{-.2cm}
\end{tabular}
}
\end{minipage}
}
\end{figure}
\vfill
\end{slide}

\begin{slide}
\rput(11.4,0.6){\includegraphics[scale=0.1]{Gen2Phen}}
\slideheading{Questions?}
\vspace{2cm}
\begin{center}
\begin{minipage}{4cm}
Acknowledgements:
\begin{itemize}
\item Peter Taschner
\item Johan den Dunnen
\end{itemize}
\end{minipage}
\end{center}
\vfill
\label{LastPage}
\end{slide}

\end{document}
