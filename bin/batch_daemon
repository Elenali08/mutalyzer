#!/usr/bin/env python

"""
Daemon for processing scheduled batch jobs.

We use python-daemon [1] for daemonizing the job processing.

@todo: Write an init script and change user.
@todo: Wrap processing in a try block, to recover from errors.

[1] http://pypi.python.org/pypi/python-daemon/
"""


import os
import sys
from daemon import pidlockfile, DaemonContext
import signal
import time
import site

# Todo: Get this from the configuration file
root_dir = os.path.split(os.path.dirname(__file__))[0]
site.addsitedir(root_dir)
# Todo: Fix Mutalyzer to not depend on working directory
if not __name__ == '__main__':
    os.chdir(root_dir)

from mutalyzer.config import Config
from mutalyzer.Db import Batch
from mutalyzer.Scheduler import Scheduler


def cleanup(signum, stack_frame):
    """
    Generate a normal exit signal.
    """
    sys.exit(1)


def daemonize():
    """
    Write PID file when it is not locked and daemonize a loop processing
    scheduled batch jobs.
    """
    config = Config()
    batch_config = config.Batch

    pidfile = os.path.realpath(batch_config.PIDfile)

    lockfile = pidlockfile.TimeoutPIDLockFile(pidfile, acquire_timeout=1,
                                              threaded=False)

    context = DaemonContext(working_directory=os.getcwd(),
                            pidfile=lockfile)

    # Writing the PID file as root before changing user/group does not seem
    # to work.
    #uid=pwd.getpwnam('www-data').pw_uid
    #gid=grp.getgrnam('www-data').gr_gid

    context.signal_map = {
        signal.SIGTERM: cleanup,
        signal.SIGHUP:  'terminate'
    }

    with context:
        # Note that any opened files are now closed. This is not a problem for
        # the Config instance, since it does not read its file again after
        # initialisation.
        database = Batch(config.Db)
        scheduler = Scheduler(config.Scheduler, database)

        def stop_scheduler(signum, stack_frame):
            scheduler.stop()
        signal.signal(signal.SIGTERM, stop_scheduler)

        while not scheduler.stopped():
            # Process batch jobs. This process() method runs while there
            # exist jobs to run.
            scheduler.process()
            if scheduler.stopped():
                break
            # Wait a bit and process any possible new jobs.
            time.sleep(60 * 2)


if __name__ == '__main__':
    daemonize()
